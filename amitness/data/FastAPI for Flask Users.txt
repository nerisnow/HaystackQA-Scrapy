While Flask has become the de-facto choice for API development in Machine Learning projects, there is a new framework called FastAPI that has been getting a lot of community traction.I recently decided to give FastAPI a spin by porting a production Flask project. It was very easy to pick up FastAPI coming from Flask and I was able to get things up and running in just a few hours.The added benefit of automatic data validation, documentation generation and baked-in best-practices such as pydantic schemas and python typing makes this a strong choice for future projects.In this post, I will introduce FastAPI by contrasting the implementation of various common use-cases in both Flask and FastAPI.
At the time of this writing, the Flask version is 1.1.2 and the FastAPI version is 0.58.1
Both Flask and FastAPI are available on PyPI. For conda, you need to use the  channel to install FastAPI while it’s available in the default channel for Flask.Now you can run the development server using the below command. It runs on port 5000 by default.FastAPI defers serving to a production-ready server called . We can run it in development mode with a default port of 8000.For a production server,  is a common choice in Flask.FastAPI defers serving to a production-ready server called . We can start the server as:You can also start it in hot-reload mode by runningFurthermore, you can change the port as well.The number of workers can be controlled as well.You can use  to manage uvicorn as well using the following command. All regular gunicorn flags such as number of workers() work.You have individual decorator methods for each HTTP method.We want to get the user id from the URL e.g.  and then return the user id to the user.In FastAPI, we make use of type hints in Python to specify all the data types. For example, here we specify that  should be an integer. The variable in the URL path is also specified similar to f-strings.We want to allow the user to specify a search term by using a query string  in the URL.Let’s take a toy example where we want to send a JSON POST request with a  key and get back a lowercased version.
If you simply replicate the functionality from Flask, you can do it as follows in FastAPI.But, this is where FastAPI introduces a new concept of creating Pydantic schema that maps to the JSON data being received. We can refactor the above example using pydantic as:As seen, instead of getting a dictionary, the JSON data is converted into an object of the schema . As such, we can access the data using data attributes such as . This also provides automatic validation of data types. If the user tries to send any data other than a string, they will be given an auto-generated validation error.Let’s create an API to return the uploaded file name. The key used when uploading the file will be .
Flask allows accessing the uploaded file via the request object.
FastAPI uses function parameter to specify the file key.We want to access a text form field that’s defined as shown below and echo the value.
Flask allows accessing the form fields via the request object.
We use function parameter to define the key and data type for the form field.We can also make the form field optional as shown belowSimilarly, we can set a default value for the form field as shown below.We want to access a cookie called  from the request.
Flask allows accessing the cookies via the request object.
We use parameter to define the key for the cookie.We want to decompose the views from a single app.py into separate files.
In Flask, we use a concept called blueprints to manage this. We would first create a blueprint for the user view as:Then, this view is registered in the main  file.
In FastAPI, the equivalent of a blueprint is called a router. First, we create a user router as:Then, we attach this router to the main app object as:
Flask doesn’t provide any input data validation feature out-of-the-box. It’s common practice to either write custom validation logic or use libraries such as  or .FastAPI wraps pydantic into its framework and allow data validation by simply using a combination of pydantic schema and python type hints.This code will perform automatic validation to ensure  is a string and  is an integer. If any other data type is sent, it auto-generates validation error with a relevant message.Here are some examples of pydantic schema for common use-cases.You can learn more about Python Type hints from .
Flask doesn’t provide any built-in feature for documentation generation. There are extensions such as  or  to fill that gap but the workflow is comparatively complex.
FastAPI automatically generates an interactive swagger documentation endpoint at  and a reference documentation at .For example, say we had a simple view given below that echoes what the user searched for.If you run the server and goto the endpoint , you will get an auto-generated swagger documentation.You can interactively try out the API from the browser itself.In addition to swagger, if you goto the endpoint , you will get an auto-generated reference documentation. There is information on parameters, request format, response format and status codes.

Flask doesn’t provide CORS support out of the box. We need to use extension such as  to configure CORS as shown below.
FastAPI provides a  to handle CORS. We show an example of CORS below where we are allowing any origin to access our APIs.Thus, FastAPI is an excellent alternative to Flask for building robust APIs with best-practices baked in. You can refer to the  to learn more.While Flask has become the de-facto choice for API development in Machine Learning projects, there is a new framework called FastAPI that has been getting a lot of community traction.I recently decided to give FastAPI a spin by porting a production Flask project. It was very easy to pick up FastAPI coming from Flask and I was able to get things up and running in just a few hours.The added benefit of automatic data validation, documentation generation and baked-in best-practices such as pydantic schemas and python typing makes this a strong choice for future projects.In this post, I will introduce FastAPI by contrasting the implementation of various common use-cases in both Flask and FastAPI.
At the time of this writing, the Flask version is 1.1.2 and the FastAPI version is 0.58.1
Both Flask and FastAPI are available on PyPI. For conda, you need to use the  channel to install FastAPI while it’s available in the default channel for Flask.Now you can run the development server using the below command. It runs on port 5000 by default.FastAPI defers serving to a production-ready server called . We can run it in development mode with a default port of 8000.For a production server,  is a common choice in Flask.FastAPI defers serving to a production-ready server called . We can start the server as:You can also start it in hot-reload mode by runningFurthermore, you can change the port as well.The number of workers can be controlled as well.You can use  to manage uvicorn as well using the following command. All regular gunicorn flags such as number of workers() work.You have individual decorator methods for each HTTP method.We want to get the user id from the URL e.g.  and then return the user id to the user.In FastAPI, we make use of type hints in Python to specify all the data types. For example, here we specify that  should be an integer. The variable in the URL path is also specified similar to f-strings.We want to allow the user to specify a search term by using a query string  in the URL.Let’s take a toy example where we want to send a JSON POST request with a  key and get back a lowercased version.
If you simply replicate the functionality from Flask, you can do it as follows in FastAPI.But, this is where FastAPI introduces a new concept of creating Pydantic schema that maps to the JSON data being received. We can refactor the above example using pydantic as:As seen, instead of getting a dictionary, the JSON data is converted into an object of the schema . As such, we can access the data using data attributes such as . This also provides automatic validation of data types. If the user tries to send any data other than a string, they will be given an auto-generated validation error.Let’s create an API to return the uploaded file name. The key used when uploading the file will be .
Flask allows accessing the uploaded file via the request object.
FastAPI uses function parameter to specify the file key.We want to access a text form field that’s defined as shown below and echo the value.
Flask allows accessing the form fields via the request object.
We use function parameter to define the key and data type for the form field.We can also make the form field optional as shown belowSimilarly, we can set a default value for the form field as shown below.We want to access a cookie called  from the request.
Flask allows accessing the cookies via the request object.
We use parameter to define the key for the cookie.We want to decompose the views from a single app.py into separate files.
In Flask, we use a concept called blueprints to manage this. We would first create a blueprint for the user view as:Then, this view is registered in the main  file.
In FastAPI, the equivalent of a blueprint is called a router. First, we create a user router as:Then, we attach this router to the main app object as:
Flask doesn’t provide any input data validation feature out-of-the-box. It’s common practice to either write custom validation logic or use libraries such as  or .FastAPI wraps pydantic into its framework and allow data validation by simply using a combination of pydantic schema and python type hints.This code will perform automatic validation to ensure  is a string and  is an integer. If any other data type is sent, it auto-generates validation error with a relevant message.Here are some examples of pydantic schema for common use-cases.You can learn more about Python Type hints from .
Flask doesn’t provide any built-in feature for documentation generation. There are extensions such as  or  to fill that gap but the workflow is comparatively complex.
FastAPI automatically generates an interactive swagger documentation endpoint at  and a reference documentation at .For example, say we had a simple view given below that echoes what the user searched for.If you run the server and goto the endpoint , you will get an auto-generated swagger documentation.You can interactively try out the API from the browser itself.In addition to swagger, if you goto the endpoint , you will get an auto-generated reference documentation. There is information on parameters, request format, response format and status codes.

Flask doesn’t provide CORS support out of the box. We need to use extension such as  to configure CORS as shown below.
FastAPI provides a  to handle CORS. We show an example of CORS below where we are allowing any origin to access our APIs.Thus, FastAPI is an excellent alternative to Flask for building robust APIs with best-practices baked in. You can refer to the  to learn more.While Flask has become the de-facto choice for API development in Machine Learning projects, there is a new framework called FastAPI that has been getting a lot of community traction.I recently decided to give FastAPI a spin by porting a production Flask project. It was very easy to pick up FastAPI coming from Flask and I was able to get things up and running in just a few hours.The added benefit of automatic data validation, documentation generation and baked-in best-practices such as pydantic schemas and python typing makes this a strong choice for future projects.In this post, I will introduce FastAPI by contrasting the implementation of various common use-cases in both Flask and FastAPI.
At the time of this writing, the Flask version is 1.1.2 and the FastAPI version is 0.58.1
Both Flask and FastAPI are available on PyPI. For conda, you need to use the  channel to install FastAPI while it’s available in the default channel for Flask.Now you can run the development server using the below command. It runs on port 5000 by default.FastAPI defers serving to a production-ready server called . We can run it in development mode with a default port of 8000.For a production server,  is a common choice in Flask.FastAPI defers serving to a production-ready server called . We can start the server as:You can also start it in hot-reload mode by runningFurthermore, you can change the port as well.The number of workers can be controlled as well.You can use  to manage uvicorn as well using the following command. All regular gunicorn flags such as number of workers() work.You have individual decorator methods for each HTTP method.We want to get the user id from the URL e.g.  and then return the user id to the user.In FastAPI, we make use of type hints in Python to specify all the data types. For example, here we specify that  should be an integer. The variable in the URL path is also specified similar to f-strings.We want to allow the user to specify a search term by using a query string  in the URL.Let’s take a toy example where we want to send a JSON POST request with a  key and get back a lowercased version.
If you simply replicate the functionality from Flask, you can do it as follows in FastAPI.But, this is where FastAPI introduces a new concept of creating Pydantic schema that maps to the JSON data being received. We can refactor the above example using pydantic as:As seen, instead of getting a dictionary, the JSON data is converted into an object of the schema . As such, we can access the data using data attributes such as . This also provides automatic validation of data types. If the user tries to send any data other than a string, they will be given an auto-generated validation error.Let’s create an API to return the uploaded file name. The key used when uploading the file will be .
Flask allows accessing the uploaded file via the request object.
FastAPI uses function parameter to specify the file key.We want to access a text form field that’s defined as shown below and echo the value.
Flask allows accessing the form fields via the request object.
We use function parameter to define the key and data type for the form field.We can also make the form field optional as shown belowSimilarly, we can set a default value for the form field as shown below.We want to access a cookie called  from the request.
Flask allows accessing the cookies via the request object.
We use parameter to define the key for the cookie.We want to decompose the views from a single app.py into separate files.
In Flask, we use a concept called blueprints to manage this. We would first create a blueprint for the user view as:Then, this view is registered in the main  file.
In FastAPI, the equivalent of a blueprint is called a router. First, we create a user router as:Then, we attach this router to the main app object as:
Flask doesn’t provide any input data validation feature out-of-the-box. It’s common practice to either write custom validation logic or use libraries such as  or .FastAPI wraps pydantic into its framework and allow data validation by simply using a combination of pydantic schema and python type hints.This code will perform automatic validation to ensure  is a string and  is an integer. If any other data type is sent, it auto-generates validation error with a relevant message.Here are some examples of pydantic schema for common use-cases.You can learn more about Python Type hints from .
Flask doesn’t provide any built-in feature for documentation generation. There are extensions such as  or  to fill that gap but the workflow is comparatively complex.
FastAPI automatically generates an interactive swagger documentation endpoint at  and a reference documentation at .For example, say we had a simple view given below that echoes what the user searched for.If you run the server and goto the endpoint , you will get an auto-generated swagger documentation.You can interactively try out the API from the browser itself.In addition to swagger, if you goto the endpoint , you will get an auto-generated reference documentation. There is information on parameters, request format, response format and status codes.

Flask doesn’t provide CORS support out of the box. We need to use extension such as  to configure CORS as shown below.
FastAPI provides a  to handle CORS. We show an example of CORS below where we are allowing any origin to access our APIs.Thus, FastAPI is an excellent alternative to Flask for building robust APIs with best-practices baked in. You can refer to the  to learn more.While Flask has become the de-facto choice for API development in Machine Learning projects, there is a new framework called FastAPI that has been getting a lot of community traction.I recently decided to give FastAPI a spin by porting a production Flask project. It was very easy to pick up FastAPI coming from Flask and I was able to get things up and running in just a few hours.The added benefit of automatic data validation, documentation generation and baked-in best-practices such as pydantic schemas and python typing makes this a strong choice for future projects.In this post, I will introduce FastAPI by contrasting the implementation of various common use-cases in both Flask and FastAPI.
At the time of this writing, the Flask version is 1.1.2 and the FastAPI version is 0.58.1
Both Flask and FastAPI are available on PyPI. For conda, you need to use the  channel to install FastAPI while it’s available in the default channel for Flask.Now you can run the development server using the below command. It runs on port 5000 by default.FastAPI defers serving to a production-ready server called . We can run it in development mode with a default port of 8000.For a production server,  is a common choice in Flask.FastAPI defers serving to a production-ready server called . We can start the server as:You can also start it in hot-reload mode by runningFurthermore, you can change the port as well.The number of workers can be controlled as well.You can use  to manage uvicorn as well using the following command. All regular gunicorn flags such as number of workers() work.You have individual decorator methods for each HTTP method.We want to get the user id from the URL e.g.  and then return the user id to the user.In FastAPI, we make use of type hints in Python to specify all the data types. For example, here we specify that  should be an integer. The variable in the URL path is also specified similar to f-strings.We want to allow the user to specify a search term by using a query string  in the URL.Let’s take a toy example where we want to send a JSON POST request with a  key and get back a lowercased version.
If you simply replicate the functionality from Flask, you can do it as follows in FastAPI.But, this is where FastAPI introduces a new concept of creating Pydantic schema that maps to the JSON data being received. We can refactor the above example using pydantic as:As seen, instead of getting a dictionary, the JSON data is converted into an object of the schema . As such, we can access the data using data attributes such as . This also provides automatic validation of data types. If the user tries to send any data other than a string, they will be given an auto-generated validation error.Let’s create an API to return the uploaded file name. The key used when uploading the file will be .
Flask allows accessing the uploaded file via the request object.
FastAPI uses function parameter to specify the file key.We want to access a text form field that’s defined as shown below and echo the value.
Flask allows accessing the form fields via the request object.
We use function parameter to define the key and data type for the form field.We can also make the form field optional as shown belowSimilarly, we can set a default value for the form field as shown below.We want to access a cookie called  from the request.
Flask allows accessing the cookies via the request object.
We use parameter to define the key for the cookie.We want to decompose the views from a single app.py into separate files.
In Flask, we use a concept called blueprints to manage this. We would first create a blueprint for the user view as:Then, this view is registered in the main  file.
In FastAPI, the equivalent of a blueprint is called a router. First, we create a user router as:Then, we attach this router to the main app object as:
Flask doesn’t provide any input data validation feature out-of-the-box. It’s common practice to either write custom validation logic or use libraries such as  or .FastAPI wraps pydantic into its framework and allow data validation by simply using a combination of pydantic schema and python type hints.This code will perform automatic validation to ensure  is a string and  is an integer. If any other data type is sent, it auto-generates validation error with a relevant message.Here are some examples of pydantic schema for common use-cases.You can learn more about Python Type hints from .
Flask doesn’t provide any built-in feature for documentation generation. There are extensions such as  or  to fill that gap but the workflow is comparatively complex.
FastAPI automatically generates an interactive swagger documentation endpoint at  and a reference documentation at .For example, say we had a simple view given below that echoes what the user searched for.If you run the server and goto the endpoint , you will get an auto-generated swagger documentation.You can interactively try out the API from the browser itself.In addition to swagger, if you goto the endpoint , you will get an auto-generated reference documentation. There is information on parameters, request format, response format and status codes.

Flask doesn’t provide CORS support out of the box. We need to use extension such as  to configure CORS as shown below.
FastAPI provides a  to handle CORS. We show an example of CORS below where we are allowing any origin to access our APIs.Thus, FastAPI is an excellent alternative to Flask for building robust APIs with best-practices baked in. You can refer to the  to learn more.While Flask has become the de-facto choice for API development in Machine Learning projects, there is a new framework called FastAPI that has been getting a lot of community traction.I recently decided to give FastAPI a spin by porting a production Flask project. It was very easy to pick up FastAPI coming from Flask and I was able to get things up and running in just a few hours.The added benefit of automatic data validation, documentation generation and baked-in best-practices such as pydantic schemas and python typing makes this a strong choice for future projects.In this post, I will introduce FastAPI by contrasting the implementation of various common use-cases in both Flask and FastAPI.
At the time of this writing, the Flask version is 1.1.2 and the FastAPI version is 0.58.1
Both Flask and FastAPI are available on PyPI. For conda, you need to use the  channel to install FastAPI while it’s available in the default channel for Flask.Now you can run the development server using the below command. It runs on port 5000 by default.FastAPI defers serving to a production-ready server called . We can run it in development mode with a default port of 8000.For a production server,  is a common choice in Flask.FastAPI defers serving to a production-ready server called . We can start the server as:You can also start it in hot-reload mode by runningFurthermore, you can change the port as well.The number of workers can be controlled as well.You can use  to manage uvicorn as well using the following command. All regular gunicorn flags such as number of workers() work.You have individual decorator methods for each HTTP method.We want to get the user id from the URL e.g.  and then return the user id to the user.In FastAPI, we make use of type hints in Python to specify all the data types. For example, here we specify that  should be an integer. The variable in the URL path is also specified similar to f-strings.We want to allow the user to specify a search term by using a query string  in the URL.Let’s take a toy example where we want to send a JSON POST request with a  key and get back a lowercased version.
If you simply replicate the functionality from Flask, you can do it as follows in FastAPI.But, this is where FastAPI introduces a new concept of creating Pydantic schema that maps to the JSON data being received. We can refactor the above example using pydantic as:As seen, instead of getting a dictionary, the JSON data is converted into an object of the schema . As such, we can access the data using data attributes such as . This also provides automatic validation of data types. If the user tries to send any data other than a string, they will be given an auto-generated validation error.Let’s create an API to return the uploaded file name. The key used when uploading the file will be .
Flask allows accessing the uploaded file via the request object.
FastAPI uses function parameter to specify the file key.We want to access a text form field that’s defined as shown below and echo the value.
Flask allows accessing the form fields via the request object.
We use function parameter to define the key and data type for the form field.We can also make the form field optional as shown belowSimilarly, we can set a default value for the form field as shown below.We want to access a cookie called  from the request.
Flask allows accessing the cookies via the request object.
We use parameter to define the key for the cookie.We want to decompose the views from a single app.py into separate files.
In Flask, we use a concept called blueprints to manage this. We would first create a blueprint for the user view as:Then, this view is registered in the main  file.
In FastAPI, the equivalent of a blueprint is called a router. First, we create a user router as:Then, we attach this router to the main app object as:
Flask doesn’t provide any input data validation feature out-of-the-box. It’s common practice to either write custom validation logic or use libraries such as  or .FastAPI wraps pydantic into its framework and allow data validation by simply using a combination of pydantic schema and python type hints.This code will perform automatic validation to ensure  is a string and  is an integer. If any other data type is sent, it auto-generates validation error with a relevant message.Here are some examples of pydantic schema for common use-cases.You can learn more about Python Type hints from .
Flask doesn’t provide any built-in feature for documentation generation. There are extensions such as  or  to fill that gap but the workflow is comparatively complex.
FastAPI automatically generates an interactive swagger documentation endpoint at  and a reference documentation at .For example, say we had a simple view given below that echoes what the user searched for.If you run the server and goto the endpoint , you will get an auto-generated swagger documentation.You can interactively try out the API from the browser itself.In addition to swagger, if you goto the endpoint , you will get an auto-generated reference documentation. There is information on parameters, request format, response format and status codes.

Flask doesn’t provide CORS support out of the box. We need to use extension such as  to configure CORS as shown below.
FastAPI provides a  to handle CORS. We show an example of CORS below where we are allowing any origin to access our APIs.Thus, FastAPI is an excellent alternative to Flask for building robust APIs with best-practices baked in. You can refer to the  to learn more.While Flask has become the de-facto choice for API development in Machine Learning projects, there is a new framework called FastAPI that has been getting a lot of community traction.I recently decided to give FastAPI a spin by porting a production Flask project. It was very easy to pick up FastAPI coming from Flask and I was able to get things up and running in just a few hours.The added benefit of automatic data validation, documentation generation and baked-in best-practices such as pydantic schemas and python typing makes this a strong choice for future projects.In this post, I will introduce FastAPI by contrasting the implementation of various common use-cases in both Flask and FastAPI.
At the time of this writing, the Flask version is 1.1.2 and the FastAPI version is 0.58.1
Both Flask and FastAPI are available on PyPI. For conda, you need to use the  channel to install FastAPI while it’s available in the default channel for Flask.Now you can run the development server using the below command. It runs on port 5000 by default.FastAPI defers serving to a production-ready server called . We can run it in development mode with a default port of 8000.For a production server,  is a common choice in Flask.FastAPI defers serving to a production-ready server called . We can start the server as:You can also start it in hot-reload mode by runningFurthermore, you can change the port as well.The number of workers can be controlled as well.You can use  to manage uvicorn as well using the following command. All regular gunicorn flags such as number of workers() work.You have individual decorator methods for each HTTP method.We want to get the user id from the URL e.g.  and then return the user id to the user.In FastAPI, we make use of type hints in Python to specify all the data types. For example, here we specify that  should be an integer. The variable in the URL path is also specified similar to f-strings.We want to allow the user to specify a search term by using a query string  in the URL.Let’s take a toy example where we want to send a JSON POST request with a  key and get back a lowercased version.
If you simply replicate the functionality from Flask, you can do it as follows in FastAPI.But, this is where FastAPI introduces a new concept of creating Pydantic schema that maps to the JSON data being received. We can refactor the above example using pydantic as:As seen, instead of getting a dictionary, the JSON data is converted into an object of the schema . As such, we can access the data using data attributes such as . This also provides automatic validation of data types. If the user tries to send any data other than a string, they will be given an auto-generated validation error.Let’s create an API to return the uploaded file name. The key used when uploading the file will be .
Flask allows accessing the uploaded file via the request object.
FastAPI uses function parameter to specify the file key.We want to access a text form field that’s defined as shown below and echo the value.
Flask allows accessing the form fields via the request object.
We use function parameter to define the key and data type for the form field.We can also make the form field optional as shown belowSimilarly, we can set a default value for the form field as shown below.We want to access a cookie called  from the request.
Flask allows accessing the cookies via the request object.
We use parameter to define the key for the cookie.We want to decompose the views from a single app.py into separate files.
In Flask, we use a concept called blueprints to manage this. We would first create a blueprint for the user view as:Then, this view is registered in the main  file.
In FastAPI, the equivalent of a blueprint is called a router. First, we create a user router as:Then, we attach this router to the main app object as:
Flask doesn’t provide any input data validation feature out-of-the-box. It’s common practice to either write custom validation logic or use libraries such as  or .FastAPI wraps pydantic into its framework and allow data validation by simply using a combination of pydantic schema and python type hints.This code will perform automatic validation to ensure  is a string and  is an integer. If any other data type is sent, it auto-generates validation error with a relevant message.Here are some examples of pydantic schema for common use-cases.You can learn more about Python Type hints from .
Flask doesn’t provide any built-in feature for documentation generation. There are extensions such as  or  to fill that gap but the workflow is comparatively complex.
FastAPI automatically generates an interactive swagger documentation endpoint at  and a reference documentation at .For example, say we had a simple view given below that echoes what the user searched for.If you run the server and goto the endpoint , you will get an auto-generated swagger documentation.You can interactively try out the API from the browser itself.In addition to swagger, if you goto the endpoint , you will get an auto-generated reference documentation. There is information on parameters, request format, response format and status codes.

Flask doesn’t provide CORS support out of the box. We need to use extension such as  to configure CORS as shown below.
FastAPI provides a  to handle CORS. We show an example of CORS below where we are allowing any origin to access our APIs.Thus, FastAPI is an excellent alternative to Flask for building robust APIs with best-practices baked in. You can refer to the  to learn more.While Flask has become the de-facto choice for API development in Machine Learning projects, there is a new framework called FastAPI that has been getting a lot of community traction.I recently decided to give FastAPI a spin by porting a production Flask project. It was very easy to pick up FastAPI coming from Flask and I was able to get things up and running in just a few hours.The added benefit of automatic data validation, documentation generation and baked-in best-practices such as pydantic schemas and python typing makes this a strong choice for future projects.In this post, I will introduce FastAPI by contrasting the implementation of various common use-cases in both Flask and FastAPI.
At the time of this writing, the Flask version is 1.1.2 and the FastAPI version is 0.58.1
Both Flask and FastAPI are available on PyPI. For conda, you need to use the  channel to install FastAPI while it’s available in the default channel for Flask.Now you can run the development server using the below command. It runs on port 5000 by default.FastAPI defers serving to a production-ready server called . We can run it in development mode with a default port of 8000.For a production server,  is a common choice in Flask.FastAPI defers serving to a production-ready server called . We can start the server as:You can also start it in hot-reload mode by runningFurthermore, you can change the port as well.The number of workers can be controlled as well.You can use  to manage uvicorn as well using the following command. All regular gunicorn flags such as number of workers() work.You have individual decorator methods for each HTTP method.We want to get the user id from the URL e.g.  and then return the user id to the user.In FastAPI, we make use of type hints in Python to specify all the data types. For example, here we specify that  should be an integer. The variable in the URL path is also specified similar to f-strings.We want to allow the user to specify a search term by using a query string  in the URL.Let’s take a toy example where we want to send a JSON POST request with a  key and get back a lowercased version.
If you simply replicate the functionality from Flask, you can do it as follows in FastAPI.But, this is where FastAPI introduces a new concept of creating Pydantic schema that maps to the JSON data being received. We can refactor the above example using pydantic as:As seen, instead of getting a dictionary, the JSON data is converted into an object of the schema . As such, we can access the data using data attributes such as . This also provides automatic validation of data types. If the user tries to send any data other than a string, they will be given an auto-generated validation error.Let’s create an API to return the uploaded file name. The key used when uploading the file will be .
Flask allows accessing the uploaded file via the request object.
FastAPI uses function parameter to specify the file key.We want to access a text form field that’s defined as shown below and echo the value.
Flask allows accessing the form fields via the request object.
We use function parameter to define the key and data type for the form field.We can also make the form field optional as shown belowSimilarly, we can set a default value for the form field as shown below.We want to access a cookie called  from the request.
Flask allows accessing the cookies via the request object.
We use parameter to define the key for the cookie.We want to decompose the views from a single app.py into separate files.
In Flask, we use a concept called blueprints to manage this. We would first create a blueprint for the user view as:Then, this view is registered in the main  file.
In FastAPI, the equivalent of a blueprint is called a router. First, we create a user router as:Then, we attach this router to the main app object as:
Flask doesn’t provide any input data validation feature out-of-the-box. It’s common practice to either write custom validation logic or use libraries such as  or .FastAPI wraps pydantic into its framework and allow data validation by simply using a combination of pydantic schema and python type hints.This code will perform automatic validation to ensure  is a string and  is an integer. If any other data type is sent, it auto-generates validation error with a relevant message.Here are some examples of pydantic schema for common use-cases.You can learn more about Python Type hints from .
Flask doesn’t provide any built-in feature for documentation generation. There are extensions such as  or  to fill that gap but the workflow is comparatively complex.
FastAPI automatically generates an interactive swagger documentation endpoint at  and a reference documentation at .For example, say we had a simple view given below that echoes what the user searched for.If you run the server and goto the endpoint , you will get an auto-generated swagger documentation.You can interactively try out the API from the browser itself.In addition to swagger, if you goto the endpoint , you will get an auto-generated reference documentation. There is information on parameters, request format, response format and status codes.

Flask doesn’t provide CORS support out of the box. We need to use extension such as  to configure CORS as shown below.
FastAPI provides a  to handle CORS. We show an example of CORS below where we are allowing any origin to access our APIs.Thus, FastAPI is an excellent alternative to Flask for building robust APIs with best-practices baked in. You can refer to the  to learn more.While Flask has become the de-facto choice for API development in Machine Learning projects, there is a new framework called FastAPI that has been getting a lot of community traction.I recently decided to give FastAPI a spin by porting a production Flask project. It was very easy to pick up FastAPI coming from Flask and I was able to get things up and running in just a few hours.The added benefit of automatic data validation, documentation generation and baked-in best-practices such as pydantic schemas and python typing makes this a strong choice for future projects.In this post, I will introduce FastAPI by contrasting the implementation of various common use-cases in both Flask and FastAPI.
At the time of this writing, the Flask version is 1.1.2 and the FastAPI version is 0.58.1
Both Flask and FastAPI are available on PyPI. For conda, you need to use the  channel to install FastAPI while it’s available in the default channel for Flask.Now you can run the development server using the below command. It runs on port 5000 by default.FastAPI defers serving to a production-ready server called . We can run it in development mode with a default port of 8000.For a production server,  is a common choice in Flask.FastAPI defers serving to a production-ready server called . We can start the server as:You can also start it in hot-reload mode by runningFurthermore, you can change the port as well.The number of workers can be controlled as well.You can use  to manage uvicorn as well using the following command. All regular gunicorn flags such as number of workers() work.You have individual decorator methods for each HTTP method.We want to get the user id from the URL e.g.  and then return the user id to the user.In FastAPI, we make use of type hints in Python to specify all the data types. For example, here we specify that  should be an integer. The variable in the URL path is also specified similar to f-strings.We want to allow the user to specify a search term by using a query string  in the URL.Let’s take a toy example where we want to send a JSON POST request with a  key and get back a lowercased version.
If you simply replicate the functionality from Flask, you can do it as follows in FastAPI.But, this is where FastAPI introduces a new concept of creating Pydantic schema that maps to the JSON data being received. We can refactor the above example using pydantic as:As seen, instead of getting a dictionary, the JSON data is converted into an object of the schema . As such, we can access the data using data attributes such as . This also provides automatic validation of data types. If the user tries to send any data other than a string, they will be given an auto-generated validation error.Let’s create an API to return the uploaded file name. The key used when uploading the file will be .
Flask allows accessing the uploaded file via the request object.
FastAPI uses function parameter to specify the file key.We want to access a text form field that’s defined as shown below and echo the value.
Flask allows accessing the form fields via the request object.
We use function parameter to define the key and data type for the form field.We can also make the form field optional as shown belowSimilarly, we can set a default value for the form field as shown below.We want to access a cookie called  from the request.
Flask allows accessing the cookies via the request object.
We use parameter to define the key for the cookie.We want to decompose the views from a single app.py into separate files.
In Flask, we use a concept called blueprints to manage this. We would first create a blueprint for the user view as:Then, this view is registered in the main  file.
In FastAPI, the equivalent of a blueprint is called a router. First, we create a user router as:Then, we attach this router to the main app object as:
Flask doesn’t provide any input data validation feature out-of-the-box. It’s common practice to either write custom validation logic or use libraries such as  or .FastAPI wraps pydantic into its framework and allow data validation by simply using a combination of pydantic schema and python type hints.This code will perform automatic validation to ensure  is a string and  is an integer. If any other data type is sent, it auto-generates validation error with a relevant message.Here are some examples of pydantic schema for common use-cases.You can learn more about Python Type hints from .
Flask doesn’t provide any built-in feature for documentation generation. There are extensions such as  or  to fill that gap but the workflow is comparatively complex.
FastAPI automatically generates an interactive swagger documentation endpoint at  and a reference documentation at .For example, say we had a simple view given below that echoes what the user searched for.If you run the server and goto the endpoint , you will get an auto-generated swagger documentation.You can interactively try out the API from the browser itself.In addition to swagger, if you goto the endpoint , you will get an auto-generated reference documentation. There is information on parameters, request format, response format and status codes.

Flask doesn’t provide CORS support out of the box. We need to use extension such as  to configure CORS as shown below.
FastAPI provides a  to handle CORS. We show an example of CORS below where we are allowing any origin to access our APIs.Thus, FastAPI is an excellent alternative to Flask for building robust APIs with best-practices baked in. You can refer to the  to learn more.While Flask has become the de-facto choice for API development in Machine Learning projects, there is a new framework called FastAPI that has been getting a lot of community traction.I recently decided to give FastAPI a spin by porting a production Flask project. It was very easy to pick up FastAPI coming from Flask and I was able to get things up and running in just a few hours.The added benefit of automatic data validation, documentation generation and baked-in best-practices such as pydantic schemas and python typing makes this a strong choice for future projects.In this post, I will introduce FastAPI by contrasting the implementation of various common use-cases in both Flask and FastAPI.
At the time of this writing, the Flask version is 1.1.2 and the FastAPI version is 0.58.1
Both Flask and FastAPI are available on PyPI. For conda, you need to use the  channel to install FastAPI while it’s available in the default channel for Flask.Now you can run the development server using the below command. It runs on port 5000 by default.FastAPI defers serving to a production-ready server called . We can run it in development mode with a default port of 8000.For a production server,  is a common choice in Flask.FastAPI defers serving to a production-ready server called . We can start the server as:You can also start it in hot-reload mode by runningFurthermore, you can change the port as well.The number of workers can be controlled as well.You can use  to manage uvicorn as well using the following command. All regular gunicorn flags such as number of workers() work.You have individual decorator methods for each HTTP method.We want to get the user id from the URL e.g.  and then return the user id to the user.In FastAPI, we make use of type hints in Python to specify all the data types. For example, here we specify that  should be an integer. The variable in the URL path is also specified similar to f-strings.We want to allow the user to specify a search term by using a query string  in the URL.Let’s take a toy example where we want to send a JSON POST request with a  key and get back a lowercased version.
If you simply replicate the functionality from Flask, you can do it as follows in FastAPI.But, this is where FastAPI introduces a new concept of creating Pydantic schema that maps to the JSON data being received. We can refactor the above example using pydantic as:As seen, instead of getting a dictionary, the JSON data is converted into an object of the schema . As such, we can access the data using data attributes such as . This also provides automatic validation of data types. If the user tries to send any data other than a string, they will be given an auto-generated validation error.Let’s create an API to return the uploaded file name. The key used when uploading the file will be .
Flask allows accessing the uploaded file via the request object.
FastAPI uses function parameter to specify the file key.We want to access a text form field that’s defined as shown below and echo the value.
Flask allows accessing the form fields via the request object.
We use function parameter to define the key and data type for the form field.We can also make the form field optional as shown belowSimilarly, we can set a default value for the form field as shown below.We want to access a cookie called  from the request.
Flask allows accessing the cookies via the request object.
We use parameter to define the key for the cookie.We want to decompose the views from a single app.py into separate files.
In Flask, we use a concept called blueprints to manage this. We would first create a blueprint for the user view as:Then, this view is registered in the main  file.
In FastAPI, the equivalent of a blueprint is called a router. First, we create a user router as:Then, we attach this router to the main app object as:
Flask doesn’t provide any input data validation feature out-of-the-box. It’s common practice to either write custom validation logic or use libraries such as  or .FastAPI wraps pydantic into its framework and allow data validation by simply using a combination of pydantic schema and python type hints.This code will perform automatic validation to ensure  is a string and  is an integer. If any other data type is sent, it auto-generates validation error with a relevant message.Here are some examples of pydantic schema for common use-cases.You can learn more about Python Type hints from .
Flask doesn’t provide any built-in feature for documentation generation. There are extensions such as  or  to fill that gap but the workflow is comparatively complex.
FastAPI automatically generates an interactive swagger documentation endpoint at  and a reference documentation at .For example, say we had a simple view given below that echoes what the user searched for.If you run the server and goto the endpoint , you will get an auto-generated swagger documentation.You can interactively try out the API from the browser itself.In addition to swagger, if you goto the endpoint , you will get an auto-generated reference documentation. There is information on parameters, request format, response format and status codes.

Flask doesn’t provide CORS support out of the box. We need to use extension such as  to configure CORS as shown below.
FastAPI provides a  to handle CORS. We show an example of CORS below where we are allowing any origin to access our APIs.Thus, FastAPI is an excellent alternative to Flask for building robust APIs with best-practices baked in. You can refer to the  to learn more.While Flask has become the de-facto choice for API development in Machine Learning projects, there is a new framework called FastAPI that has been getting a lot of community traction.I recently decided to give FastAPI a spin by porting a production Flask project. It was very easy to pick up FastAPI coming from Flask and I was able to get things up and running in just a few hours.The added benefit of automatic data validation, documentation generation and baked-in best-practices such as pydantic schemas and python typing makes this a strong choice for future projects.In this post, I will introduce FastAPI by contrasting the implementation of various common use-cases in both Flask and FastAPI.
At the time of this writing, the Flask version is 1.1.2 and the FastAPI version is 0.58.1
Both Flask and FastAPI are available on PyPI. For conda, you need to use the  channel to install FastAPI while it’s available in the default channel for Flask.Now you can run the development server using the below command. It runs on port 5000 by default.FastAPI defers serving to a production-ready server called . We can run it in development mode with a default port of 8000.For a production server,  is a common choice in Flask.FastAPI defers serving to a production-ready server called . We can start the server as:You can also start it in hot-reload mode by runningFurthermore, you can change the port as well.The number of workers can be controlled as well.You can use  to manage uvicorn as well using the following command. All regular gunicorn flags such as number of workers() work.You have individual decorator methods for each HTTP method.We want to get the user id from the URL e.g.  and then return the user id to the user.In FastAPI, we make use of type hints in Python to specify all the data types. For example, here we specify that  should be an integer. The variable in the URL path is also specified similar to f-strings.We want to allow the user to specify a search term by using a query string  in the URL.Let’s take a toy example where we want to send a JSON POST request with a  key and get back a lowercased version.
If you simply replicate the functionality from Flask, you can do it as follows in FastAPI.But, this is where FastAPI introduces a new concept of creating Pydantic schema that maps to the JSON data being received. We can refactor the above example using pydantic as:As seen, instead of getting a dictionary, the JSON data is converted into an object of the schema . As such, we can access the data using data attributes such as . This also provides automatic validation of data types. If the user tries to send any data other than a string, they will be given an auto-generated validation error.Let’s create an API to return the uploaded file name. The key used when uploading the file will be .
Flask allows accessing the uploaded file via the request object.
FastAPI uses function parameter to specify the file key.We want to access a text form field that’s defined as shown below and echo the value.
Flask allows accessing the form fields via the request object.
We use function parameter to define the key and data type for the form field.We can also make the form field optional as shown belowSimilarly, we can set a default value for the form field as shown below.We want to access a cookie called  from the request.
Flask allows accessing the cookies via the request object.
We use parameter to define the key for the cookie.We want to decompose the views from a single app.py into separate files.
In Flask, we use a concept called blueprints to manage this. We would first create a blueprint for the user view as:Then, this view is registered in the main  file.
In FastAPI, the equivalent of a blueprint is called a router. First, we create a user router as:Then, we attach this router to the main app object as:
Flask doesn’t provide any input data validation feature out-of-the-box. It’s common practice to either write custom validation logic or use libraries such as  or .FastAPI wraps pydantic into its framework and allow data validation by simply using a combination of pydantic schema and python type hints.This code will perform automatic validation to ensure  is a string and  is an integer. If any other data type is sent, it auto-generates validation error with a relevant message.Here are some examples of pydantic schema for common use-cases.You can learn more about Python Type hints from .
Flask doesn’t provide any built-in feature for documentation generation. There are extensions such as  or  to fill that gap but the workflow is comparatively complex.
FastAPI automatically generates an interactive swagger documentation endpoint at  and a reference documentation at .For example, say we had a simple view given below that echoes what the user searched for.If you run the server and goto the endpoint , you will get an auto-generated swagger documentation.You can interactively try out the API from the browser itself.In addition to swagger, if you goto the endpoint , you will get an auto-generated reference documentation. There is information on parameters, request format, response format and status codes.

Flask doesn’t provide CORS support out of the box. We need to use extension such as  to configure CORS as shown below.
FastAPI provides a  to handle CORS. We show an example of CORS below where we are allowing any origin to access our APIs.Thus, FastAPI is an excellent alternative to Flask for building robust APIs with best-practices baked in. You can refer to the  to learn more.