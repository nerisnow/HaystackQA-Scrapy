Word Embeddings are one of the most interesting aspects of the Natural Language Processing field. When I first came across them, it was intriguing to see a simple recipe of unsupervised training on a bunch of text yield representations that show signs of syntactic and semantic understanding.In this post, we will explore a word embedding algorithm called “FastText” that was introduced by  and understand how it enhances the Word2Vec algorithm from 2013.Suppose we have the following words and we want to represent them as vectors so that they can be used in Machine Learning models.Ronaldo, Messi, DicaprioA simple idea could be to perform a one-hot encoding of the words, where each word gets a unique position.We can see that this sparse representation doesn’t capture any relationship between the words and every word is isolated from each other.Maybe we could do something better. We know Ronaldo and Messi are footballers while Dicaprio is an actor. Let’s use our world knowledge and create manual features to represent the words better.This is better than the previous one-hot-encoding because related items are closer in space.
We could keep on adding even more aspects as dimensions to get a more nuanced representation.But manually doing this for every possible word is not scalable. If we designed features based on our world knowledge of the relationship between words, can we replicate the same with a neural network?Can we have neural networks comb through a large corpus of text and generate word representations automatically?This is the intention behind the research in word-embedding algorithms.In 2013,  introduced an efficient method to learn vector representations of words from large amounts of unstructured text data. The paper was an execution of this idea from Distributional Semantics.You shall know a word by the company it keeps - J.R. Firth 1957Since similar words appear in a similar context, Mikolov et al. used this insight to formulate two tasks for representation learning.The first was called “” where need to predict the center words given the neighbor words. 

The second task was called “” where we need to predict the neighbor words given a center word.
Representations learned had interesting properties such as this popular example where arithmetic operations on word vectors seemed to retain meaning. 
While Word2Vec was a game-changer for NLP, we will see how there was still some room for improvement::
In Word2Vec, an embedding is created for each word. As such, it can’t handle any words it has not encountered during its training.For example, words such as “” and “” are present in the vocabulary of Word2Vec. But if you try to get embedding for the compound word “”, you will get an .
:
For words with same radicals such as “eat” and “eaten”, Word2Vec doesn’t do any parameter sharing. Each word is learned uniquely based on the context it appears in. Thus, there is scope for utilizing the internal structure of the word to make the process more efficient.To solve the above challenges,  proposed a new embedding method called FastText. Their key insight was to use the internal structure of a word to improve vector representations obtained from the skip-gram method.The modification to the skip-gram method is applied as follows:For a word, we generate character n-grams of length 3 to 6 present in it.Then, we generate character n-grams of length n. For example, for the word “eating”, character n-grams of length 3 can be generated by sliding a window of 3 characters from the start of the angular bracket till the ending angular bracket is reached. Here, we shift the window one step each time.
Thus, we get a list of character n-grams for a word.

Examples of different length character n-grams are given below:Since there can be huge number of unique n-grams, we apply hashing to bound the memory requirements. Instead of learning an embedding for each unique n-gram, we learn total B embeddings where B denotes the bucket size. The paper used a bucket of a size of 2 million.

Each character n-gram is hashed to an integer between 1 to B. Though this could result in collisions, it helps control the vocabulary size. The paper uses the FNV-1a variant of the  function to hash character sequences to integer values.To understand the pre-training, let’s take a simple toy example. We have a sentence with a center word “eating” and need to predict the context words “am” and “food”.First, the embedding for the center word is calculated by taking a sum of vectors for the character n-grams and the whole word itself.
For the actual context words, we directly take their word vector from the embedding table without adding the character n-grams.
Now, we collect negative samples randomly with probability proportion to the square root of the unigram frequency. For one actual context word, 5 random negative words are sampled.
We take dot product between the center word and the actual context words and apply sigmoid function to get a match score between 0 and 1.Based on the loss, we update the embedding vectors with SGD optimizer to bring actual context words closer to the center word but increase distance to the negative samples.
FastText improves performance on syntactic word analogy tasks significantly for morphologically rich language like Czech and German.FastText has degraded performance on semantic analogy tasks compared to Word2Vec.
FastText is 1.5 times slower to train than regular skipgram due to added overhead of n-grams.Using sub-word information with character-ngrams has better performance than CBOW and skip-gram baselines on word-similarity task. Representing out-of-vocab words by summing their sub-words has better performance than assigning null vectors.To train your own embeddings, you can either use the  or use the  available in gensim.Pre-trained word vectors trained on Common Crawl and Wikipedia for 157 languages are available  and variants of English word vectors are available .